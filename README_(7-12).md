## 7. Функції

Функція — це фрагмент коду, який можна використати багато разів. Вона може приймати різні аргументи та повертати якийсь результат.

Головна перевага функцій — це звільнення від дублювання коду.

### Оголошення функції (function declaration)

Для створення ф-ції використовується ключове слово `function`. Розглянемо приклад:

```css
function sayHello(personName) {
console.log(`Hello, ${personName}!`);
}
```

Де:

- `function` — вказує нам, що це саме функція;
- `sayHello` — ім'я функції;
- `personName` — параметр ф-ції. Параметрів може бути декілька, тоді їх потрібно записати через кому, або не бути взагалі, тоді дужки `()` слід залишити порожніми;
- у фігурних дужках `{}` знаходиться тіло функції — це команди, які вона виконує.

  **Зверни увагу:** ім'я краще починати з дієслова-дії, яка виконується функцією. Перше слово потрібно починати з маленької літери, а наступні — з великої:

```css
// гарне ім'я
function sayHello(personName) { // описує призначення функції
console.log(`Hello, ${personName}!`);
}

// погані імена
function func(personName) { // з назви не зрозуміло, що відбувається у функції
console.log(`Hello, ${personName}!`);
}

function sayhello(personName) { // описує призначення, але друге слово написано з маленької літери
console.log(`Hello, ${personName}!`);
}
```

### Виклик функції

Щоб викликати функцію, потрібно написати її ім'я, а далі в круглих дужках вказати аргументи (якщо вони є).

Розглянемо попередній приклад і передамо у функцію `sayHello()` різні аргументи:

```css
sayHello('Misha'); // 'Hello, Misha!'
sayHello('Roma'); // 'Hello, Roma!'
```

Ти можеш викликати ф-цію ще до того, як її було оголошено:

```css
printSum(3, 2); // 5

function printSum(x, y) {
console.log(x + y);
}
```

**Зверни увагу:** значення `3` потрапить у `x`, а `2` — у `y`.

### Повернення значення з функції

Щоб ф-ція повернула якесь значення, у тіло потрібно написати ключове слово `return`, а праворуч вказати значення чи вираз, який потрібно повернути.

Розглянемо приклад:

```css
function getRectangleSquare(a, b) {
const square = a \* b;

return square;
}
```

Результат функції підставляється в те місце, де її викликали. У прикладі нижче результат запишеться в змінну, що стоїть ліворуч від `=`:

```css
const square1 = getRectangleSquare(3, 2);
console.log(square1); // 6

const square2 = getRectangleSquare(4, 5);
console.log(square2); // 20
```

Розглянемо ще один приклад, де результат функції не записується в змінну (у цьому випадку результат просто ігнорується):

```css
function sum(x, y) {
return x + y;
}

console.log(
sum(2, 2), // 4
sum(5, 7), // 12
);
```

Якщо у функції немає ключового слова `return` або праворуч від `return` немає значення, то результатом буде `undefined`:

```css
function f1() {}

function f2() {
return;
}

console.log(
f1(), // undefined
f2(), // undefined
);
```

**Зверни увагу:** `return` повністю завершує виконання поточної ф-ції, тобто наступні команди не виконуватимуться:

```css
function sum(x, y) {
return x + y;

// цей рядок ніколи не буде викликаний
console.log(`Sum of ${x} and ${y} is ${x + y}`);
}
```

---

## 8. Умовні оператори

Як ти вже знаєш, команди в програмі виконуються послідовно (згори донизу). Але іноді потрібно, щоб деякі команди виконувались лише за певною умовою. У цих випадках використовуються умовні оператори.

Розглянемо їх докладніше.

### Конструкція if

**Перевірка однієї умови**
Якщо тобі потрібно перевірити лише одну умову, використай конструкцію `if`

Розглянемо приклад:

```css
let age = 16;

console.log('Ідемо до магазину');

if (age >= 18) {
// цей рядок виконається тільки якщо age не менше 18
console.log('Ти можеш купити алкоголь');
}

console.log('Повертаємось додому');
```

Після ключового слова `if` потрібно поставити круглі дужки `()`, а в них записати умову. Далі фігурні дужки `{}`, всередині яких ми пишемо команди — це тіло блоку. Тіло блоку виконається, тільки якщо умова є істинною.

Тут умова — це `age >= 18`. Оскільки `age = 16` і умова не виконалася, то й команда всередині блоку не виконалася. Тому в консолі ми отримаємо:

```
Ідемо до магазину
Повертаємось додому
```

**Перевірка декількох умов**
Якщо потрібно перевірити декілька умов, можна використати `if` всередині іншого `if`. Наприклад:

```css
if (isAdult) {
if (hasEnoughMoney) {
console.log('Ти можеш купити алкоголь');
}
}
```

Але за такою **вкладеною** конструкцією дуже складно стежити, наприклад, де дужки відкрилися, а де закрилися. Тому краще використовувати логічні оператори `&&` та `||` для об'єднання умов.

Приклад перевірки двох умов із використанням оператора `&&`:

```css
if (isAdult && hasEnoughMoney) {
console.log('Ти можеш купити алкоголь');
}
```

Приклад перевірки двох умов із використанням оператора `||`:

```css
if (hasEnoughCash || hasCreditLimit) {
console.log('Ти можеш купити цукерки');
}
```

Детальніше про логічні оператори ти можеш почитати в уроці **Булевий тип**.

### Конструкція else

Іноді потрібно виконати різні команди, залежно від того, істинна умова чи хибна. Це можна зробити за допомогою двох конструкцій `if` із протилежними умовами. Наприклад:

```css
if (isAdult) {
console.log('Виконалася умова isAdult === true');
}

if (!isAdult) {
console.log('Виконалася умова isAdult !== true');
}
```

Але є коротший і зручніший спосіб зробити те саме — використати `else`:

```css
if (isAdult) {
console.log('Виконалася умова isAdult === true');
} else {
console.log('Виконалася умова isAdult !== true');
}
```

Якщо виконається умова if, то в консолі ми побачимо:

```
Виконалася умова isAdult === true
```

Інакше в консолі ми побачимо:

```
Виконалася умова isAdult !== true
```

### Конструкція else if

Якщо потрібно виконати одну команду з кількох, залежно від умови, то можна використати конструкцію `else if`.

Розглянемо приклад:

```css
if (age >= 18) {
console.log('Дорослий');
} else if (age >= 10) {
// виконається, якщо age < 18 і age >= 10
console.log('Підліток');
} else if (age > 3) {
// виконається, якщо age < 10 і age > 3
console.log('Дитина');
}
```

При `age = 5` у консолі ми отримаємо: `Дитина`.

Також у кінці можна додати `else`, який спрацює, якщо жодна з умов вище не виконалася:

```css
if (age >= 18) {
console.log('Дорослий');
} else if (age >= 10) {
console.log('Підліток');
} else if (age > 3) {
console.log('Дитина');
} else {
console.log('Немовля');
}
```

При `age = 1` у консолі ми отримаємо: `Немовля`.

### Ключове слово return всередині if

Якщо `if` використовується всередині ф-ції, то можна скористатися ключовим словом `return`, щоб позбутись `else` і `else if`.

Розглянемо приклад:

```css
function getTitle(age) {
if (age >= 18) {
// якщо age >= 18 — виходимо з функції
return 'Дорослий';
}

// сюди програма дійде, тільки якщо умова age >= 18 не виконалася
// отже, у наступному коді ми точно знаємо, що age < 18
if (age >= 10) {
// якщо age >= 10 (але < 18) — виходимо з функції
return 'Підліток';
}

// сюди ми потрапляємо, тільки якщо не вийшли з функції раніше
// це означає, що age < 18 та age < 10
return 'Дитина';
}
```

Передаючи різні значення `age`, у консолі ми побачимо:

```css
console.log(
// 27 >= 18, тому ми потрапили до першого if і відразу повернули значення 'Дорослий'
getTitle(27),

// перший if не спрацював, тому перевірили умову 16 >= 10 і повернули значення 'Підліток'
getTitle(16),

// перший і другий if не спрацювали, тому дійшли до кінця й повернули значення 'Дитина'
getTitle(2),

// перший if не спрацював, тому перевірили умову 10 >= 10 і повернули значення 'Підліток'
getTitle(10),
);
```

### Умовний (тернарний) оператор

Іноді необхідно записати різні значення в змінну залежно від умови. Це можна зробити за допомогою `if` та `else`:

```css
let age = 23;
let result = '';

// умова
if (age >= 18) {
// значення1
result = 'Дорослий';
} else {
// значення2
result = 'Не дорослий';
}

console.log(result); // 'Дорослий'
```

Але це не дуже зручно з двох причин:

1. Занадто велика конструкція.
2. Ми не зможемо використати `const` для змінної `result`, тому що нам потрібно записати в неї нове значення всередині `if else`.
   Є коротший та зручніший варіант запису — **умовний (тернарний) оператор**. Розглянемо приклад:

```css
let age = 23;
const result = age >= 18 ? 'Дорослий' : 'Не дорослий';

console.log(result); // 'Дорослий'
```

Якщо умова `age >= 18` виконалася (як у нашому прикладі), то буде обрано те, що стоїть після `?` (`'Дорослий'`), інакше — те, що стоїть після `:` (`'Не дорослий'`).

Для наочності, вираз в умові можна взяти в дужки:

```css
const result = (age >= 18) ? 'Дорослий' : 'Не дорослий';
```

Якщо вираз довгий, то можна переносити значення на нові рядки:

```css
const result = (age >= 18)
? 'Дорослий'
: 'Не дорослий';
```

Цей оператор часто називають тернарним, оскільки це єдиний оператор, у якому використовуються 3 частини.

---

## 9. Цикли (loops)

Часто у своїх програмах тобі потрібно буде повторювати ті самі команди кілька разів. Для цього використовуються цикли. У цьому уроці ми розглянемо цикл `for`, а також розберемо приклади його використання.

Для початку розгляньмо такий приклад:

```css
for (let age = 3; age < 10; age = age + 1) {
// цей рядок виконається 7 разів для age від 3 до 9
console.log(`My age is ${age}`);
}
```

Де:

`let age = 3` — стартова команда, яка виконується лише один раз перед початком циклу;
`age < 10 `— умова, яка перевірятиметься перед кожною ітерацією (виконанням тіла) циклу. Якщо вона істинна (true), то виконається наступна ітерація;
`age = age + 1` — команда, яка виконуватиметься після кожної ітерації циклу.
У консолі ми побачимо:

```
My age is 3
My age is 4
My age is 5
My age is 6
My age is 7
My age is 8
My age is 9
```

### Скорочене присвоєння

Команду `age = age + 1` можна записати за допомогою операції скороченого присвоєння — `age += 1`.

При цьому збільшувати значення можна на будь-яке число, наприклад:

```css
age += 1; // age = age + 1;
age += 10; // age = age + 10;
```

Скорочене присвоєння можна використовувати й для інших арифметичних операцій:

```css
age -= 5; // age = age - 5;
age *= 5; // age = age * 5;
age /= 5; // age = age / 5;
age %= 5; // age = age % 5;
```

Найчастіше число в циклі збільшують або зменшують на `1`, і тому ці операції можна записати ще так:

```css
age++; // age += 1;
age--; // age -= 1;
```

**Зверни увагу:** операція `++` називається **інкрементом**, а `--` — **декрементом**.

### Фіксована кількість повторень

Цикл `for` часто використовують, щоб повторити якусь команду задану к-сть разів.

Розглянемо приклад:

```css
for (let i = 0; i < 3; i++) {
console.log('Ця команда виконається 3 рази');
console.log(i);
}
```

У консолі побачимо такий результат:

```
Ця команда виконається 3 рази
0

Ця команда виконається 3 рази
1

Ця команда виконається 3 рази
2
```

**Зверни увагу:** змінну циклу часто називають `i` від слова `index` — покажчик.

### Як працює цикл

А тепер покроково розберемо, як відбувається виконання циклу. Погляньмо на попередній приклад:

1 Спочатку виконується команда `let i = 0`.
2 Далі перевіряється умова `i < 3` (`0 < 3`) — `true`.
3 Виконується тіло циклу `console.log(i);` при `i === 0`.
4 Виконується команда `i++` (тепер `i === 1`).
5 Знову перевіряється умова `i < 3` (`1 < 3`) — `true`.
6 Виконується тіло циклу `console.log(i)`; при `i === 1`.
7 Виконується команда `i++` (тепер `i === 2`).
8 Знову перевіряється умова `i < 3` (`2 < 3`) — `true`.
9 Виконується тіло циклу `console.log(i);` при `i === 2`.
10 Виконується команда `i++` (тепер `i === 3`).
11 Перевіряється умова `i < 3` (`3 < 3`) — `false`.
12 Цикл завершено.

### Перебір у зворотному напрямку

Іноді буває зручно розпочати перебір з кінця. Розглянемо приклад:

```css
for (let i = 3; i > 0; i--) {
console.log(i);
}
```

У консолі ми побачимо:

```
3
2
1
```

**Зверни увагу:** у цьому прикладі ми зберегли `3` у змінну циклу `let i = 3`, і після кожної ітерації циклу ми зменшуємо її значення на `1`, а не збільшуємо.

### Цикл із кроком

Також ми можемо створювати цикли із кроком. Це означає, що після кожної ітерації `i` змінюється не на 1, а на інше задане значення. Розглянемо приклад:

```css
// збільшуємо значення i на 10, починаючи з 5
for (let i = 5; i < 30; i += 10) {
console.log(i);
}
```

У консолі ми отримаємо такий результат:

```
5
15
25
```

Інший приклад:

```css
// збільшуємо значення i в 3 рази
for (let i = 1; i < 30; i \*= 3) {
console.log(i);
}
```

У консолі ми отримаємо такий результат:

```
1
3
9
27
```

### Сума чисел від 1 до N

За допомогою циклу можна підсумувати числа. Наприклад:

```css
const n = 5;
let sum = 0;

for (let i = 1; i <= n; i++) {
sum += i; // 1 + 2 + 3 + 4 + 5
}

console.log(sum); // 15
```

---

## 10. Робота з рядками

У цьому уроці ти продовжиш знайомитися з рядками та на практиці розбереш методи, які спрощують роботу з ними.

### Довжина рядка

Дізнатися довжину рядка (кількість символів у ньому) можна за допомогою властивості `length`. Наприклад:

```css
const fullName = 'Misha Hrynko';

console.log(fullName.length); // 12
```

### Символ у рядку

Отримати окремий символ у рядку можна за його індексом. Індекси в рядку починаються з `0` (не з `1`).

Наприклад:

```css
const fullName = 'Misha Hrynko';

console.log(
fullName[0], // 'M'
fullName[1], // 'i'
fullName[5], // ' '
fullName[11], // 'o'

// індекс останнього символа на 1 менше за довжину рядка
fullName[fullName.length - 1]; // 'o'
);
```

Якщо в такий спосіб ти спробуєш отримати символ у рядку за неіснуючим індексом, то результат буде `undefined`:

```css
const name = 'Misha';

console.log(
name[0], // 'M'
name[10], // undefined
);
```

### Перебір рядка

Часто потрібно перебрати всі символи в рядку. Для цього підійде цикл `for`:

```css
const name = 'Misha';

for (let i = 0; i < name.length; i++) {
console.log(name[i]);
}
```

У консолі побачимо такий результат:

```
M
i
s
h
a
```

Використовуючи цикл, можна підрахувати кількість певних символів у рядку, наприклад, пробілів:

```css
const text = 'My name is Misha';
let spacesCount = 0;

for (let i = 0; i < text.length; i++) {
// рахуємо скільки пробілів у рядку
if (text[i] === ' ') {
spacesCount++;
}
}

console.log(spacesCount); // 3
```

### Перебір без індексу

Перебір символів у рядку можна зробити циклом `for of`. У такому разі індекси не використовуються:

```css
const name = 'Misha';

for (const letter of name) {
console.log(letter);
}
```

На кожному кроці в змінну `letter` записується черговий символ рядка `name`.

У консолі ми побачимо:

```
M
i
s
h
a
```

### Зміна рядка

Якщо треба замінити символ у рядку, то зробити це як у прикладі нижче **не вийд**е:

```css
let text = '0123456789';
text[2] = 'X';
```

Рядок, що вже існує, змінити не можна. Але можна створити новий рядок та наповнити його потрібними символами, наприклад, у циклі:

```css
const text = 'My name is Misha';
// пізніше в цю змінну ми запишемо новий рядок із потрібними символами
let result = '';

for (let i = 0; i < text.length; i++) {
if (text[i] === ' ') {
// замінюємо пробіл на '---'
result = result + '---';
} else {
// додаємо всі інші символи без змін
result = result + text[i];
}
}

console.log(result); // 'My---name---is---Misha'
```

**Зверни увагу:** команди виду `result = result + '---'` скорочують до `result += '---'`.

Цей підхід використовується для видалення символів у рядку:

```css
const text = 'My name is Misha';
let result = '';

for (let i = 0; i < text.length; i++) {
if (text[i] !== ' ') {
// додаємо все, крім пробілів
result += text[i];
}
}

console.log(result); // 'MynameisMisha'
```

### Отримання підрядка

Досить часто тобі потрібно буде отримувати частину рядка (підрядок). І тут зручно скористатися методом `slice()`. Він приймає 2 аргументи:

- індекс, з якого починається копіювання символів;
- індекс, на якому закінчується копіювання символів. Символ за цим індексом не буде включений.

Наприклад:

```css
const text = '0123456789';

console.log(
// символ з індексом 5 не буде включений
text.slice(1, 5), // '1234'

// беремо перші 8 символів
text.slice(0, 8), // '01234567'

// якщо початок більший за кінець, отримуємо пустий рядок
text.slice(5, 1), // ''

// без аргументів отримуємо весь рядок
text.slice(), // '0123456789'

// якщо другий аргумент не переданий, беремо все до кінця
text.slice(2), // '23456789'

// якщо індекс початку занадто великий, отримаємо пустий рядок
text.slice(15), // ''

// від'ємні індекси рахуються з кінця
text.slice(-5, -2), // '567'

// беремо останні 3 символа
text.slice(-3), // '789'

// усі символи окрім 0-го та останнього
text.slice(1, -1), // '12345678'
);
```

Цей метод можна використати, щоб зібрати новий рядок із частин:

```css
const text = 'I have 4 dogs';

// 'I have five dogs'
const text2 = text.slice(0, 7) + 'five' + text.slice(-5);

// 'We don't have dogs'
const text3 = `We don't ${text.slice(2, 6)} ${text.slice(-4)}`;
```

### Пошук підрядка

За допомогою методу `includes()` можна перевірити, чи містить рядок певний символ або підрядок, наприклад:

```css
const name = 'Misha';

console.log(
name.includes('M'), // true
name.includes('e'), // false

// у рядку є тільки велика літера `M`
name.includes('m'), // false

// шукаємо підрядок
name.includes('Mis'), // true
name.includes('mis'), // false

// підрядок шукається повністю, а не окремі літери
name.includes('ia'), // false
);
```

Пошук можна розпочати не з початку, а із зазначеного індексу. Для цього потрібно передати стартовий індекс другим аргументом, наприклад:

```css
const word = 'abrakadabra';

console.log(
word.includes('k'), // true

// 'k' стоїть на 4-ому індексі, а ми починаємо перевірку з 5-го
word.includes('k', 5), // false

// якщо індекс більше довжини рядка, повертаємо false
word.includes('b', 15), // false

// якщо індекс від'ємний, шукаємо з кінця рядка
word.includes('b', -1), // true
word.includes('b', -100), // true
);
```

### Регістр тексту

Методи `toUpperCase()` та `toLowerCase()` повертають новий рядок, у якому всі символи вхідного рядка будуть у верхньому або нижньому регістрі.

Наприклад:

```css
const name = 'Misha';

console.log(
name.toLowerCase(), // 'misha'
name.toUpperCase(), // 'MISHA'

name[0].toLowerCase(), // 'm'
name[0].toUpperCase(), // 'M'
);
```

**Зверни увагу:** змінити регістр можна **тільки** для літер:

```css
console.log(
'1'.toLowerCase(), // '1'
'1'.toUpperCase(), // '1'
','.toUpperCase(), // ','
' '.toUpperCase(), // ' '
''.toUpperCase(), // ''
);
```

Ця особливість дозволяє перевірити, чи є символ літерою:

```css
function isLetter(ch) {
return ch.toLowerCase() !== ch.toUpperCase();
}

console.log(
isLetter('a'), // true
isLetter('B'), // true
isLetter('1'), // false
isLetter(','), // false
isLetter(' '), // false
);
```

Код нижче перевіряє, чи є літера великою:

```css
function isBigLetter(ch) {
return ch !== ch.toLowerCase();
}

console.log(
isBigLetter('A'), // true
isBigLetter('a'), // false
isBigLetter('1'), // false
isBigLetter(','), // false
isBigLetter(' '), // false
);
```

### Регістронезалежний пошук

Якщо ти хочеш перевірити, чи містить рядок певний підрядок без урахування регістру, то потрібно привести рядок і підрядок до одного регістру (наприклад, до нижнього):

```css
function search(text, part) {
const normalizedText = text.toLowerCase();
const normalizedPart = part.toLowerCase();

return normalizedText.includes(normalizedPart);
}

console.log(
search('Misha', 'm'), // true
search('Misha', 'SHA'), // true
);
```

### Початок і кінець рядка

За допомогою методу `startsWith()` можна визначити, чи починається рядок із певного підрядка, а `endsWith()` — чи закінчується рядок певним підрядком.

Наприклад:

```css
const name = 'Misha';

console.log(
name.startsWith('Mis'), // true
name.startsWith('Misha'), // true
name.startsWith('M'), // true

name.startsWith('is'), // false
name.startsWith('a'), // false
);

console.log(
name.endsWith('a'), // true
name.endsWith('sha'), // true
name.endsWith('Misha'), // true

name.endsWith('is'), // false
name.endsWith('Mi'), // false
);
```

### Видалення пробілів

За допомогою методу `trim()` можна видалити всі пробіли на початку та в кінці рядку, наприклад:

```css
const name = ' Misha';
const fullName = 'Misha Hrynko ';
const word = ' abrakadabra ';

console.log(
name.trim(), // 'Misha'
fullName.trim(), // 'Misha Hrynko'
word.trim(), // 'abrakadabra'
);
```

### Пошук індексу

Щоб дізнатися, де в рядку вперше зустрічається символ чи підрядок, можна використати метод `indexOf()`. Якщо символ або підрядок знайдено, то повернеться індекс першого входження. Якщо не знайдені — повернеться `-1`.

Наприклад:

```css
const name = 'My name is Misha';

console.log(
name.indexOf('y'), // 1
name.indexOf('n'), // 3
name.indexOf('My'), // 0

// символ не знайдений
name.indexOf('x'), // -1

// регістр має значення
name.indexOf('my'), // -1

// індекс першого входження
name.indexOf('M'), // 0
name.indexOf('a'), // 4
name.indexOf(' '), // 2

// маленька літера 'm' стоїть шостою
name.indexOf('m'), // 5
);
```

Якщо пошук позиції потрібно почати з певного індексу, передай його другим аргументом:

```css
const name = 'My name is Misha';

console.log(
name.indexOf('M'), // 0
name.indexOf('M', 1), // 11

// 'M' не трапляється, починаючи з 12 індекса
name.indexOf('M', 12), // -1
);
```

Існує метод для пошуку індексу у зворотному напрямку — `lastIndexOf()`. Він повертає індекс останнього входження символу або підрядка:

```css
const name = 'My name is Misha';

console.log(
name.lastIndexOf('y'), // 1
name.lastIndexOf('M'), // 11

// можна вказати індекс, з якого починається пошук у зворотній бік
name.lastIndexOf('M', 10), // 0
);
```

### Перетворення в рядок і назад

Іноді потрібно перетворити число на рядок. Це можна зробити кількома способами:

```css
const n = -123;

console.log(
String(n), // '-123'
n.toString(), // '-123'
`${n}`, // '-123'
'' + n, // '-123'
);
```

Таким способом можна отримати окрему цифру числа:

```css
function getFirstDigit(n) {
return String(n)[0];
}

console.log(
getFirstDigit(123), // '1'
getFirstDigit(76543), // '7'
getFirstDigit(0), // '0'
);
```

Але коли ми працюємо із символами, результат завжди є рядком. Якщо далі потрібно буде число, то доведеться зробити явне приведення типів:

```css
const digits = '123';

console.log(
Number(digits), // 123
+digits, // 123
);
```

На практиці найчастіше використовують оператор `+`.

### Округлення значень

Дуже часто в процесі обчислень у тебе будуть виходити не цілі числа, а дробові. Їх можна округлити:

- `Math.round(x)` — округляє x до найближчого цілого (вгору або вниз):

```css
console.log(
Math.round(10.1), // 10
Math.round(10.5), // 11
Math.round(10.8), // 11
Math.round(-10.1), // -10
Math.round(-10.5), // -10
Math.round(-10.8), // -11
);
```

- `Math.floor(x)` — округляє x вниз (до найближчого меншого цілого):

```css
console.log(
Math.floor(10.1), // 10
Math.floor(10.5), // 10
Math.floor(10.8), // 10
Math.floor(-10.1), // -11
Math.floor(-10.5), // -11
Math.floor(-10.8), // -11
);
```

- `Math.ceil(x)` — округляє x вгору (до найближчого більшого цілого):

```css
console.log(
Math.ceil(10.1), // 11
Math.ceil(10.5), // 11
Math.ceil(10.8), // 11
Math.ceil(-10.1), // -10
Math.ceil(-10.5), // -10
Math.ceil(-10.8), // -10
);
```

---

## 11. Масиви

У реальному житті ми дуже часто стикаємося з великою кількістю однотипних даних: слова в словнику, оцінки в журналі, товари в магазині, книги на полиці тощо. В Javascript для роботи з такими даними використовуються масиви. Наприклад:

```css
const weekDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
const numbers = [2, 5, 3, 4, 5, 1, 3];
const words = ['one', 'two', 'tree'];

// це пустий масив, в ньому поки що немає елементів
const friends = [];

// так теж можна створити масив, але на практиці користуються []
const marks = new Array(2, 5, 3, 4, 5, 1, 3);
```

За допомогою метода `split` ти можеш створити масив із рядка. Він використовується для розбиття рядка на масив підрядків за заданим роздільником, наприклад:

```css
const str = "Javascript is awesome";
const words = str.split(" "); // Розбиває рядок на масив підрядків за пробілами
console.log(words); // [ 'Javascript', 'is', 'awesome' ]
```

### Довжина масиву

Довжину масиву (кількість елементів у ньому) можна одержати за допомогою властивості `length`. Наприклад, для масивів, створених вище:

```css
console.log(
numbers.length, // 7
words.length, // 3
);
```

### Елемент масиву

Елемент масиву можна отримати за його індексом:

```css
const weekDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

console.log(
weekDays[0], // 'Sunday'
weekDays[1], // 'Monday'
weekDays[6], // 'Saturday'

// якщо індекс занадто великий, отримуємо undefined
weekDays[10], // undefined

// чи від'ємний
weekDays[-2], // undefined
);
```

Також можна скористатися методом `at()`. Він працює так само, як arr[index] для додатніх індексів, але обробляє негативні як `arr[arr.length - index]`. Наприклад:

```css
console.log(
weekDays.at(-1), // 'Saturday'
weekDays.at(-2), // 'Friday'
weekDays.at(1), // 'Monday'
);
```

### Перебір масиву

Часто необхідно перебрати всі елементи масиву. Для цього підійде цикл **for**. Також можна використати цикл `for of` — у такому разі індекси не використовуються:

```css
const numbers = [2, 5, 3, 4, 5, 1, 3];

for (let i = 0; i < numbers.length; i++) {
console.log(numbers[i]);
}

for (const n of numbers) {
console.log(n);
}
```

В обох випадках у консолі ми побачимо:

```
2
5
3
4
5
1
3
```

### Вибір елементу за критерієм

Якщо потрібно вибрати один елемент із масиву за якимось критерієм, можна створити змінну й у неї зберігати проміжний результат.

Функція нижче повертає найдовше слово з масиву:

```css
function getTheLongestWord(words) {
// перше слово поки що найдовше
let theLongest = words[0];

// починаємо перебір із другого елементу
for (let i = 1; i < words.length; i++) {
// якщо поточне слово довше theLongest
if (words[i].length >theLongest.length) {
// то зберігаємо його замість попереднього theLongest
theLongest = words[i];
}
}

// повертаємо найдовше слово
return theLongest;
}

// отримаємо 'three'
getTheLongestWord(['one', 'two', 'three', 'four', 'five']);
```

Таке порівняння можливе, тільки якщо масив містить хоча б один елемент. Якщо масив порожній, то потрібно вирішити, що повертати в цьому разі. Наприклад, порожній рядок:

```css
function getTheLongestWord(words) {
if (words.length === 0) {
return '';
}

// далі той же код, що й раніше
}
```

### Середнє значення елементів масиву

Щоб знайти середнє значення елементів масиву, потрібно обчислити суму всіх елементів та розділити її на кількість елементів. Наприклад:

```css
function getAverage(numbers) {
// у цю змінну ми будемо додавати числа
let sum = 0;

for (const n of numbers) {
// додаємо кожне число до суми
sum += n;
}

// ділимо суму на кількість чисел
return sum / numbers.length;
}
```

Але якщо масив порожній, то ділитимемо ми на `0`, а це помилка обчислень. Такий випадок потрібно передбачити на початку ф-ції — якщо в масиві немає елементів, то повертаємо `0`:

```css
function getAverage(numbers) {
if (numbers.length === 0) {
return 0;
}

// далі той же код, що і раніше
}
```

Часто середнє значення округляють:

- `Math.round(x)` — округляє `x` до найближчого цілого (вгору або вниз):

```css
console.log(
Math.round(10.1), // 10
Math.round(10.5), // 11
Math.round(10.8), // 11
Math.round(-10.1), // -10
Math.round(-10.5), // -10
Math.round(-10.8), // -11
);
```

- `Math.floor(x)` — округляє `x` вниз (до найближчого меншого цілого):

```css
console.log(
Math.floor(10.1), // 10
Math.floor(10.5), // 10
Math.floor(10.8), // 10
Math.floor(-10.1), // -11
Math.floor(-10.5), // -11
Math.floor(-10.8), // -11
);
```

- `Math.ceil(x)` — округляє `x` вгору (до найближчого більшого цілого):

```css
console.log(
Math.ceil(10.1), // 11
Math.ceil(10.5), // 11
Math.ceil(10.8), // 11
Math.ceil(-10.1), // -10
Math.ceil(-10.5), // -10
Math.ceil(-10.8), // -10
);
```

Таким чином, ми можемо округлити середнє значення елементів масиву:

```css
function getAverage(numbers) {
// тут код не змінюється

// округляємо до найближчого цілого
return Math.round(sum / numbers.length);
}
```

### Порівняння елементів масиву

Якщо потрібно порівняти сусідні елементи масиву, можна зробити перебір, як у функції `getMaxDifference()`. Вона повертає найбільшу різницю між сусідніми елементами масиву:

```css
function getMaxDifference(numbers) {
// якщо всього один елемент або масив порожній, то рахувати різницю немає сенсу
if (numbers.length < 2) {
return 0;
}

// знаходимо першу різницю
let maxDifference = numbers[1] - numbers[0];

// починаємо перебір із 3 елементу
for (let i = 2; i < numbers.length; i++) {
const current = numbers[i]; // поточне число
const previous = numbers[i - 1]; // попереднє число
const difference = current - previous;

    if (difference > maxDifference) {
      maxDifference = difference;
    }

}

return maxDifference;
}
```

### Редагування масиву

На відміну від символу в рядку, елемент у масиві можна замінити за його індексом:

```css
const numbers = [1, 2, 3, 4, 5];

numbers[1] = 100;
console.log(numbers); // [1, 100, 3, 4, 5]
```

### Додавання елементу в масив

Також можна додати новий елемент до масиву:

```css
const numbers = [1, 2, 3, 4, 5];

numbers[5] = 100;
console.log(numbers); // [1, 2, 3, 4, 5, 100]
```

**Зверни увагу:** якщо ми вкажемо неправильний індекс, то масив працюватиме некоректно:

```css
const numbers = [1, 2, 3];

numbers[5] = 100;
console.log(numbers); // [1, 2, 3, empty, empty, 100]
```

Щоб уникнути помилки з попереднього прикладу, для додавання елементів до масиву використовуй метод `push()`:

```css
const numbers = [1, 2, 3];

numbers.push(100);
console.log(numbers); // [1, 2, 3, 100]

// можна додати одразу декілька елементів
numbers.push(4, 5, 6);
console.log(numbers); // [1, 2, 3, 100, 4, 5, 6]
```

Для додавання елементу на початок масиву існує метод `unshift()`:

```css
const numbers = [1, 2, 3];

numbers.unshift(100);
console.log(numbers); // [100, 1, 2, 3]

// можна додати одразу декілька елементів
numbers.unshift(4, 5, 6);
console.log(numbers); // [4, 5, 6, 100, 1, 2, 3]
```

### Видалення елементу з масиву

Метод `pop()` видаляє останній елемент із масиву, а `shift()` — перший. Наприклад:

```css
const numbers = [1, 2, 3, 4, 5];

numbers.pop();
console.log(numbers); // [1, 2, 3, 4]

numbers.shift();
console.log(numbers); // [2, 3, 4]
```

### Новий масив на базі існуючого

Часто ми отримуємо масив із даними, з якого потрібно створити новий масив результатів. І тут можна скористатися циклом.

Наприклад, функція отримує масив слів і має повернути масив із довжинами слів:

```css
function getWordsLengths(words) {
// створюємо порожній масив для результатів
const result = [];

// перебираємо початковий масив
for (const word of words) {
// додаємо довжину слова до масиву результатів
result.push(word.length);
}

// повертаємо масив результатів
return result;
}

// отримаємо [3, 3, 5, 4, 4]
getWordsLengths(['one', 'two', 'three', 'four', 'five']);
```

### Фільтрування елементів масиву

Іноді потрібно створити новий масив, де будуть ті елементи вихідного масиву, які задовольняють умові. У такому випадку можна додати умову в цикл як у прикладі нижче:

```css
function getLongWords(words) {
const result = [];

for (const word of words) {
// перевіряємо чи підходить нам елемент
if (word.length > 3) {
// додаємо до результату тільки відповідні елементи
result.push(word);
}
}

return result;
}
```

### Пошук елементів у масиві

Щоб перевірити, чи є в масиві певний елемент, можна скористатися методами `includes()`, `indexOf()` та `lastIndexOf()`. Вони працюють аналогічно методам рядків. Наприклад:

```css
const words = ['one', 'two', 'three', 'one'];

console.log(
words.includes('two'), // true
words.indexOf('one'), // 0
words.lastIndexOf('one'), // 3

// не трапляється, починаючи з індекса 2
words.includes('two', 2), // false
words.indexOf('two', 2), // -1

// перше входження, починаючи з індекса 1
words.indexOf('one', 1), // 3

// літера 'w' не є окремим елементом масиву
words.includes('w'), // false
);
```

### Частина вхідного масиву

Щоб створити новий масив з елементів масиву, що вже існує, можна використати метод `slice()`. Він працює аналогічно методу `slice()` для рядків:

```css
const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

console.log(
numbers.slice(3, 8), // [3, 4, 5, 6, 7]

// перші 5 елементів
numbers.slice(0, 5), // [0, 1, 2, 3, 4]

// елементи від індексу 4 до кінця
numbers.slice(4), // [4, 5, 6, 7, 8, 9]

// усі елементи масиву
numbers.slice(), // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

// від'ємні індекси рахуються з кінця
numbers.slice(-4, -2), // [6, 7]

// усі елементи, крім першого та останнього
numbers.slice(1, -1), // [1, 2, 3, 4, 5, 6, 7, 8]

// останні 3 елементи
numbers.slice(-3), // [7, 8, 9]
);
```

### Об'єднання елементів масиву в рядок

Метод `join` використовується для об'єднання елементів масиву в рядок. Він приймає роздільник як аргумент і повертає рядок, утворений з об'єднаних елементів масиву:

```css
const words = ['Javascript', 'is', 'awesome'];
const str = words.join(' '); // Об'єднує елементи масиву пробілами
console.log(str); // 'Javascript is awesome'
```

---
